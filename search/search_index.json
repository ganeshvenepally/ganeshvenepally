{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>My name is Ganesh Venepally. I'm a Network Engineer with 15+ years of experience. Most part of my career I worked for major financial banks building and supporting thier complex networks. My technical background includes network design,implementations and operations.</p> <p>Here I try to write about interesting technical challenges I face in my daily work and I hope you'll find something helpful to take away.</p> <p>If you want to get in touch you can PM me on twitter.</p>"},{"location":"Finance/","title":"Section to Track my Finance related Work","text":""},{"location":"Finance/DCA/","title":"Python Script to Backtest DCA","text":"<pre><code>import os\nimport pandas as pd\nimport yfinance as yf\nfrom datetime import datetime, timedelta\n\ndef get_trading_dates(start_date, end_date):\n    trading_dates = pd.bdate_range(start_date, end_date, freq='W')\n    return trading_dates\n\ndef record_data(date, ETF_price, shares_purchased, total_investment, total_shares, weekly_investment, ROI=None, final_results=False):\n    return {\n        'date': date,\n        'ETF_price': ETF_price,\n        'shares_purchased': shares_purchased,\n        'total_investment': total_investment,\n        'total_shares': total_shares,\n        'weekly_investment': weekly_investment,\n        'ROI': ROI,\n        'final_results': final_results\n    }\n\ndef calculate_final_results(data_records, weekly_investment):\n    last_record = data_records[-1]\n    total_investment = last_record['total_investment']\n    total_shares = last_record['total_shares']\n    ETF_price = last_record['ETF_price']\n    final_portfolio_value = total_shares * ETF_price\n\n    ROI = (final_portfolio_value - total_investment) / total_investment\n\n    max_portfolio_value = 0\n    max_drawdown = 0\n    for record in data_records:\n        portfolio_value = record['total_shares'] * record['ETF_price']\n        max_portfolio_value = max(max_portfolio_value, portfolio_value)\n        drawdown = (max_portfolio_value - portfolio_value) / max_portfolio_value\n        max_drawdown = max(max_drawdown, drawdown)\n\n    return {\n        'total_investment': total_investment,\n        'total_shares': total_shares,\n        'final_portfolio_value': final_portfolio_value,\n        'ROI': ROI,\n        'max_drawdown': max_drawdown,\n        'weekly_investment': weekly_investment\n    }\n\ndef DCA(ETF_ticker, start_date, end_date, weekly_investment):\n    trading_dates = get_trading_dates(start_date, end_date)\n    ETF_data = yf.download(ETF_ticker, start=start_date, end=end_date, progress=False)\n\n    data_records = []\n\n    for date in trading_dates:\n        if date not in ETF_data.index:\n            date = date + timedelta(days=1)\n            while date not in ETF_data.index:\n                date = date + timedelta(days=1)\n\n        ETF_price = ETF_data.loc[date, 'Close']\n        shares_purchased = weekly_investment / ETF_price\n        total_investment = (len(data_records) + 1) * weekly_investment\n        total_shares = sum([record['shares_purchased'] for record in data_records]) + shares_purchased\n\n        ROI = (total_shares * ETF_price - total_investment) / total_investment\n        data_records.append(record_data(date, ETF_price, shares_purchased, total_investment, total_shares, weekly_investment, ROI))\n\n    final_results = calculate_final_results(data_records, weekly_investment)\n    data_records.append(record_data(None, None, None, final_results['total_investment'], final_results['total_shares'], weekly_investment, final_results['ROI'], final_results=True))\n\n    return data_records, final_results\n\nETF_ticker = 'TQQQ'\nstart_date = '2011-01-23'\nend_date = '2023-4-04'\nweekly_investment = 100\n\ndata, final_results = DCA(ETF_ticker, start_date, end_date, weekly_investment)\n\ndf = pd.DataFrame(data)\nprint(df)\n\n# Create a folder for the output file if it doesn't exist\noutput_folder = 'DCA'\nif not os.path.exists(output_folder):\n    os.makedirs(output_folder)\n\n# Save the DataFrame as a CSV file\noutput_file = os.path.join(output_folder, 'DCA_data.csv')\ndf.to_csv(output_file, index=False)\n\nprint(f\"Total investment: ${final_results['total_investment']:.2f}\")\nprint(f\"Total shares: {final_results['total_shares']:.2f}\")\nprint(f\"Final portfolio value: ${final_results['final_portfolio_value']:.2f}\")\nprint(f\"ROI: {final_results['ROI'] * 100:.2f}%\")\nprint(f\"Max Drawdown: {final_results['max_drawdown'] * 100:.2f}%\")\n</code></pre>"},{"location":"network-automation/","title":"Network Automation","text":"<p>Welcome to my blog on Network Automation! In today's fast-paced business environment, organizations are constantly looking for ways to improve the efficiency and reliability of their network operations. One of the key ways to achieve this is through automation.</p> <p>Network automation is the use of software and tools to automate repetitive or complex tasks associated with the management and configuration of network devices. This can include tasks such as configuring and provisioning new devices, monitoring and troubleshooting network issues, and managing software and security updates.</p> <p>The goal of network automation is to increase the speed and reliability of network operations, while reducing the risk of errors and downtime. With automation, network engineers can focus on more strategic and value-added tasks, such as designing and implementing new network solutions, rather than spending their time on manual and repetitive tasks.</p> <p>In this blog, I will explore various aspects of network automation, including the use of automation tools, best practices for implementing automation, and how automation can be used to improve the security and performance of networks.</p> <p>Whether you are new to network automation or an experienced network engineer looking to expand your skills, this blog is designed to provide valuable insights and tips to help you improve the efficiency and effectiveness of your network operations.</p>"},{"location":"network-automation/01-netdevops/","title":"NetDevOps","text":"NetDevOps Pipeline <p>DevOps is a set of practices and tools that aim to improve collaboration and communication between development and operations teams in order to increase the speed and quality of software delivery. In the context of network operations, DevOps practices can be applied to the management and automation of network infrastructure in order to improve the speed and reliability of network changes, as well as reduce the risk of errors and downtime.</p> <p>One key aspect of DevOps in network context is the use of automation and scripting to manage network devices and configurations. This can include using tools such as Ansible, Puppet, or Chef to automate the configuration of network devices, as well as using version control systems such as Git to manage and track changes to network configurations.</p> <p>CI/CD - Another important aspect of DevOps in network context is the use of continuous integration and continuous delivery (CI/CD) to manage the deployment and testing of network changes. This can include using automated testing and validation tools to ensure that changes to the network are safe and functional before they are deployed to production. Additionally, it also includes monitoring and metrics tools to track the performance and availability of the network.</p> <p>Cultural Shift - In addition to these technical practices, DevOps in network context also involves a cultural shift towards a more collaborative and cross-functional approach to network operations. This can include breaking down silos between different teams such as network engineers, developers, and system administrators, and fostering a culture of transparency, communication, and continuous improvement.</p> <p>Overall, the goal of DevOps in network context is to improve the speed, reliability, and security of network operations, while reducing the risk of errors and downtime. By applying DevOps practices and tools to network management, organizations can improve the efficiency and effectiveness of their network operations and deliver better network services to their customers.</p>"},{"location":"network-automation/02-data-models-encodings/","title":"Data Models and Encodings","text":"<p>Data models and encodings are important concepts in networking that are used to represent and manage the configuration and state of network devices and services.</p> <p>A data model is a structured representation of the data that a network device or service uses to configure and operate. This can include information such as network topology, device configurations, and performance metrics. Data models are typically defined using formal languages such as YANG, which is used to model network configurations and state data for various protocols such as IP, MPLS, and LACP.</p> <p>An encoding is a method used to represent the data defined by a data model in a format that can be transmitted and processed by network devices and management systems. There are several encoding formats that are commonly used in networking, including XML, JSON. Each encoding format has its own strengths and weaknesses, and the choice of encoding format will depend on the specific requirements of the network and the devices and systems that will be using the data.</p> <p>In Networking, data models are used to define the structure of the data, while encodings are used to represent the data in a format that can be transmitted over the network. For example, a YANG model can be used to define the structure of the data for a particular protocol such as BGP, and then that data can be encoded in JSON format to be transmitted over the network and processed by the devices and systems that are using the BGP protocol.</p> <p>One of the main benefits of using data models and encodings in networking is that they allow for a more consistent and efficient management of network devices and services. Data models provide a standard way to represent the data, which allows for better interoperability between devices and systems.</p>"},{"location":"network-automation/02-data-models-encodings/#yang","title":"YANG","text":"<p>YANG (Yet Another Next Generation) is a data modeling language used to model the configuration and state data for various network protocols such as IP, MPLS, and LACP. It is used by several networking vendors, such as Cisco and Juniper, to define the data models for their devices and services. For example, a YANG data model can be used to define the structure of the data for a particular protocol such as BGP, and then that data can be encoded in JSON format to be transmitted over the network and processed by the devices and systems that are using the BGP protocol.</p>"},{"location":"network-automation/02-data-models-encodings/#xml","title":"XML","text":"<p>XML (Extensible Markup Language) is a markup language that is commonly used in networking to represent and manage the configuration and state of network devices and services. Here are some examples of how XML is used in networking.</p> <p>Network Management Protocols: XML is used to represent data in several network management protocols such as SNMP (Simple Network Management Protocol) and NETCONF (Network Configuration). These protocols use XML to represent the data in a structured and easily readable format, which allows network management systems to easily extract and process the data.</p> <p>Here is the sample CLI output of Junos <code>BGP Config</code> can be encoded with XML:</p> CLI outputXML output <pre><code>protocols {\nbgp {\n    group G1 {\n        type external;\n        peer-as 64501;\n        neighbor 10.0.0.1;\n    }\n    group G2 {\n        type external;\n        peer-as 64502;\n        neighbor 10.0.10.1;\n    }\n}\n}\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;configuration&gt;\n&lt;protocols&gt;\n    &lt;bgp&gt;\n    &lt;group&gt;\n        &lt;name&gt;G1&lt;/name&gt;\n        &lt;type&gt;external&lt;/type&gt;\n        &lt;peer-as&gt;64501&lt;/peer-as&gt;\n        &lt;neighbor&gt;\n        &lt;name&gt;10.0.0.1&lt;/name&gt;\n        &lt;/neighbor&gt;\n    &lt;/group&gt;\n    &lt;group&gt;\n        &lt;name&gt;G2&lt;/name&gt;\n        &lt;type&gt;external&lt;/type&gt;\n        &lt;peer-as&gt;64502&lt;/peer-as&gt;\n        &lt;neighbor&gt;\n        &lt;name&gt;10.0.10.1&lt;/name&gt;\n        &lt;/neighbor&gt;\n    &lt;/group&gt;\n    &lt;/bgp&gt;\n&lt;/protocols&gt;\n&lt;/configuration&gt;\n</code></pre>"},{"location":"network-automation/02-data-models-encodings/#json","title":"JSON","text":"<p>JSON: JavaScript Object Notation (JSON) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate. JSON is widely used in networking because it is easy to understand, it is easy to parse, and it is easy to generate. JSON can be used as an encoding format for data models defined in YANG, as it is easy to read and write. JSON can also be used to represent the data in RESTful APIs, which are widely used in networking to manage devices and services.</p> <p>Here is the sample data from previous sections encoded in JSON:</p> <pre><code>{\n  \"configuration\": {\n    \"protocols\": {\n      \"bgp\": {\n        \"group\": [\n          {\n            \"name\": \"G1\",\n            \"type\": \"external\",\n            \"peer-as\": \"64501\",\n            \"neighbor\": [\n              {\n                \"name\": \"10.0.0.1\"\n              }\n            ]\n          },\n          {\n            \"name\": \"G2\",\n            \"type\": \"external\",\n            \"peer-as\": \"64502\",\n            \"neighbor\": [\n              {\n                \"name\": \"10.0.10.1\"\n              }\n            ]\n          }\n        ]\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"network-automation/02-data-models-encodings/#yaml","title":"YAML","text":"<p>YAML: YAML Ain't Markup Language (YAML) is a data serialization format that is often used in networking for configuration management. YAML is often preferred over JSON and XML because it is more human-readable and less verbose. YAML is widely used for configuration management, for example Ansible, a widely popular automation tool, uses YAML to define the configuration of devices.</p> <p>Here is the sample data from previous sections encoded in YAML:</p> <pre><code>---\nconfiguration:\n  protocols:\n    bgp:\n      group:\n      - name: G1\n        type: external\n        peer-as: '64501'\n        neighbor:\n        - name: 10.0.0.1\n      - name: G2\n        type: external\n        peer-as: '64502'\n        neighbor:\n        - name: 10.0.10.1\n</code></pre>"},{"location":"network-automation/02-data-models-encodings/#summary","title":"Summary","text":"<p>Here is a summary table that compares the key properties of XML, JSON, and YAML:</p> Property XML JSON YAML Structure Hierarchical, nested tree structure Key-value pairs Indentation-based, human-readable Readability Verbose, not as human-readable as JSON or YAML Easy to read and write Easy to read and write Parsing Requires specialized parsing libraries Can be parsed with a wide range of libraries Can be parsed with a wide range of libraries Platform Independence Platform-independent Platform-independent Platform-independent Verbosity Verbose Less verbose than XML Less verbose than XML Popularity Commonly used in networking, but less popular than JSON Widely used in web and mobile apps, becoming more popular in networking Commonly used in configuration management and automation"},{"location":"network-automation/03-python/","title":"Index","text":"<p>Python is a powerful programming language that has become increasingly popular in the field of network automation. With its simple syntax, vast libraries, and flexibility, Python makes it easy to automate tasks such as network configuration, monitoring, and troubleshooting.</p> <p>This Section is dedicated to providing tips, tutorials, and best practices for using Python to automate network tasks and improve network management. It will cover topics such as using Python libraries such as Netmiko, NAPALM, and PyEZ to automate network device configuration and management, using Python to perform network monitoring and troubleshooting, and using Python to integrate with network automation tools such as Ansible, and Nornir.</p>"},{"location":"network-automation/03-python/01-virtual-environmet/","title":"Virtual Environment","text":"<p>Creating a Python virtual environment is a good practice to isolate your Python project's dependencies and avoid conflicts with other projects. Here's an example of how you can create a virtual environment using the venv module in Python 3:</p>"},{"location":"network-automation/03-python/01-virtual-environmet/#example","title":"Example","text":"<ul> <li> <p>Open a command prompt and navigate to the directory where you want to create the virtual environment.</p> </li> <li> <p>Run the following command to create a new virtual environment:</p> </li> </ul> <pre><code>python -m venv myenv\n</code></pre> <p>This will create a new directory called \"myenv\" that contains the files needed for the virtual environment.</p> <ul> <li>To activate the virtual environment, run the following command:</li> </ul> <pre><code>myenv\\Scripts\\activate.bat\n</code></pre> <ul> <li>*Once the virtual environment is activated, you should see the name of the virtual environment in the command prompt, for example:</li> </ul> <pre><code>(myenv) C:\\myproject&gt;\n</code></pre> <ul> <li>To install packages in the virtual environment, you can use pip, for example:</li> </ul> <pre><code>(myenv) C:\\myproject&gt; pip install requests\n</code></pre> <ul> <li>To deactivate the virtual environment, you can simply run the command:</li> </ul> <pre><code>deactivate\n</code></pre> <p>It's worth noting that the myenv directory is a copy of the python executable and all the standard libraries, this means that the virtual environment is not dependent of the global python installation and you can have multiple versions of a package or libraries installed.</p> <p>You can also use other tools such as conda, virtualenvwrapper, pipenv and more to manage virtual environments, each of them have its own advantages and usecases, you can refer to the documentation of the tool you choose to learn more about them.</p>"},{"location":"network-automation/03-python/02-paramiko/","title":"Paramiko","text":"<p>Paramiko is a Python library that provides an SSH2 protocol implementation for secure and automated access to network devices such as routers and switches. It allows you to establish an SSH connection to a network device and execute commands or transfer files.</p>"},{"location":"network-automation/03-python/02-paramiko/#examples","title":"Examples","text":"<p>Here are a few examples of how you can use paramiko to automate tasks on Cisco routers:</p> <ul> <li>Connecting to a Cisco router: Paramiko can be used to establish an SSH connection to a Cisco router. Here's an example of how to connect to a router using Paramiko:</li> </ul> <pre><code>import paramiko\n\n# Create a new SSH client\nclient = paramiko.SSHClient()\n\n# Add the Cisco router's IP address and username/password to connect\nclient.connect('192.168.1.1', username='admin', password='password')\n</code></pre> <ul> <li>Running commands on a Cisco router: Once connected, Paramiko can be used to run commands on a Cisco router. Here's an example of how to run the \"show version\" command on a router:</li> </ul> <pre><code># Open an SSH channel\nchannel = client.invoke_shell()\n\n# Send the command to the router\nchannel.send('show version\\n')\n\n# Receive the output from the router\noutput = channel.recv(9999)\nprint(output.decode())\n</code></pre> <ul> <li>Transferring files to/from a Cisco router: Paramiko can also be used to transfer files to and from a Cisco router. Here's an example of how to transfer a file to a Cisco router:</li> </ul> <pre><code># Open an SFTP session\nsftp = client.open_sftp()\n\n# Transfer the file to the router\nsftp.put('local_file.txt', 'remote_file.txt')\n</code></pre> <p>These are just a few examples of the many ways that Paramiko can be used to interact with Cisco routers. With Paramiko, you can automate tasks such as configuring interfaces, managing VLANs, and troubleshooting network issues, among others. It also can be used with other networking vendors like Juniper, Arista, etc.</p>"},{"location":"network-automation/03-python/03-netmiko/","title":"Netmiko","text":"<p>Netmiko is a Python library built on top of Paramiko, which simplifies automating network device configuration and management tasks. It is designed to work with Cisco, Arista, Juniper, and other network vendors.</p>"},{"location":"network-automation/03-python/03-netmiko/#examples","title":"Examples","text":"<p>Here are a few examples of how Netmiko can be used to interact with Cisco routers: </p> <ul> <li>Connecting to a Cisco router: Netmiko can be used to establish an SSH connection to a Cisco router. Here's an example of how to connect to a router using Netmiko:</li> </ul> <pre><code>from netmiko import ConnectHandler\n\n# Define the device parameters\ndevice = {\n    'device_type': 'cisco_ios',\n    'ip': '192.168.1.1',\n    'username': 'admin',\n    'password': 'password',\n}\n\n# Connect to the device\nnet_connect = ConnectHandler(**device)\n</code></pre> <ul> <li>Running commands on a Cisco router: Once connected, Netmiko can be used to run commands on a Cisco router. Here's an example of how to run the \"show version\" command on a router:</li> </ul> <pre><code>output = net_connect.send_command(\"show version\")\nprint(output)\n</code></pre> <ul> <li>Configuring a Cisco router: Netmiko can also be used to configure Cisco routers. Here's an example of how to configure an interface on a Cisco router:</li> </ul> <pre><code># Define the configuration commands\ncommands = [\n    'interface FastEthernet0/1',\n    'description Configured by Netmiko',\n    'ip address 192.168.1.10 255.255.255.0',\n    'no shutdown'\n]\n\n# Send the configuration commands to the device\nnet_connect.send_config_set(commands)\n</code></pre> <p>Netmiko provides a simple and consistent interface to interact with network devices and automate tasks such as configuration management, backup, troubleshooting and more. It supports a wide range of network vendors and platforms, and it includes support for SSH, Telnet and serial connections.</p>"},{"location":"network-automation/03-python/04-nornir/","title":"Nornir","text":"<p>Nornir is a Python automation framework that is designed to automate network tasks, it's built on top of the popular libraries such as Netmiko and Napalm. It allows for parallel execution of tasks, and provides an easy-to-use inventory system to manage devices.</p>"},{"location":"network-automation/03-python/04-nornir/#examples","title":"Examples","text":"<p>Here are a few examples of how Nornir can be used to interact with Cisco routers:</p> <ul> <li>Creating an inventory: Nornir uses an inventory system to manage the devices. Here's an example of how to create an inventory of Cisco routers:</li> </ul> <pre><code>from nornir import InitNornir\nfrom nornir.plugins.inventory import SimpleInventory\n\n# Define the devices\ndevices = {\n    \"cisco_router1\": {\n        \"hostname\": \"192.168.1.1\",\n        \"username\": \"admin\",\n        \"password\": \"password\",\n        \"platform\": \"cisco_ios\",\n    },\n    \"cisco_router2\": {\n        \"hostname\": \"192.168.1.2\",\n        \"username\": \"admin\",\n        \"password\": \"password\",\n        \"platform\": \"cisco_ios\",\n    },\n}\n\n# Create the inventory\nnr = InitNornir(inventory=SimpleInventory(hosts=devices))\n</code></pre> <ul> <li>Running commands on a Cisco router: Once connected, Nornir can be used to run commands on a Cisco router. Here's an example of how to run the \"show version\" command on a router using Nornir:</li> </ul> <pre><code>from nornir import InitNornir\nfrom nornir.plugins.tasks import networking\n\n# Initialize Nornir\nnr = InitNornir(inventory={'options': {'host_file': 'hosts.yaml'}})\n\n# Run the command on the device\nresult = nr.run(networking.netmiko_send_command, command_string='show version')\n\n# Print the output\nprint(result['cisco_router'].result)\n</code></pre> <ul> <li>Configuring a Cisco router: Nornir can also be used to configure Cisco routers. Here's an example of how to configure an interface on a Cisco router using Nornir:</li> </ul> <pre><code>from nornir import InitNornir\nfrom nornir.plugins.tasks import networking\n\n# Initialize Nornir\nnr = InitNornir(inventory={'options': {'host_file': 'hosts.yaml'}})\n\n# Define the configuration commands\ncommands = [ 'interface FastEthernet0/1',\n'description Configured by Nornir',\n'ip address 192.168.1.10 255.255.255.0',\n'no shutdown' ]\n</code></pre> <ul> <li>Send the configuration commands to the device and Print the result</li> </ul> <pre><code>result = nr.run(networking.netmiko_send_config, config_commands=commands)\nprint(result['cisco_router'].result)\n</code></pre> <p>Nornir provides a powerful and flexible way to automate network tasks across multiple devices. It allows you to define devices and their connection details in a single file, and it also provides a simple and consistent way to run commands and configure devices.  It also allows to perform parallel execution, gather data and perform filtering, and more.</p>"},{"location":"network-automation/03-python/nornir_pyeapi/","title":"Nornir pyeapi","text":"In\u00a0[2]: Copied! <pre>!pip install nornir nornir_utils pyeapi\n</pre> !pip install nornir nornir_utils pyeapi <pre>Requirement already satisfied: nornir in c:\\users\\ganes\\.conda\\envs\\pynr\\lib\\site-packages (3.4.1)\nRequirement already satisfied: nornir_utils in c:\\users\\ganes\\.conda\\envs\\pynr\\lib\\site-packages (0.2.0)\nRequirement already satisfied: pyeapi in c:\\users\\ganes\\.conda\\envs\\pynr\\lib\\site-packages (1.0.4)\nRequirement already satisfied: mypy_extensions&lt;2.0.0,&gt;=1.0.0 in c:\\users\\ganes\\.conda\\envs\\pynr\\lib\\site-packages (from nornir) (1.0.0)\nRequirement already satisfied: ruamel.yaml&gt;=0.17 in c:\\users\\ganes\\.conda\\envs\\pynr\\lib\\site-packages (from nornir) (0.18.6)\nRequirement already satisfied: colorama&lt;0.5.0,&gt;=0.4.3 in c:\\users\\ganes\\.conda\\envs\\pynr\\lib\\site-packages (from nornir_utils) (0.4.6)\nRequirement already satisfied: netaddr in c:\\users\\ganes\\.conda\\envs\\pynr\\lib\\site-packages (from pyeapi) (1.3.0)\nRequirement already satisfied: ruamel.yaml.clib&gt;=0.2.7 in c:\\users\\ganes\\.conda\\envs\\pynr\\lib\\site-packages (from ruamel.yaml&gt;=0.17-&gt;nornir) (0.2.8)\n</pre> In\u00a0[3]: Copied! <pre>from nornir import InitNornir\n\n# Initialize Nornir with your config.yaml\nnr = InitNornir(config_file=\"config.yaml\")\n\n# Display the initialized Nornir object\nnr\n</pre> from nornir import InitNornir  # Initialize Nornir with your config.yaml nr = InitNornir(config_file=\"config.yaml\")  # Display the initialized Nornir object nr  Out[3]: <pre>&lt;nornir.core.Nornir at 0x1ffa3c1e540&gt;</pre> In\u00a0[4]: Copied! <pre># Display all hosts in the inventory\nnr.inventory.hosts\n</pre> # Display all hosts in the inventory nr.inventory.hosts Out[4]: <pre>{'arista_switch1': Host: arista_switch1,\n 'arista_switch2': Host: arista_switch2}</pre> In\u00a0[5]: Copied! <pre># Get details of a specific host\nhost = nr.inventory.hosts[\"arista_switch1\"]\n\n# Print hosname and data\nprint(f\"Hostname: {host.hostname}\")\nprint(f\"Usernamme: {host.username}\")\nprint(f\"Password: {host.password}\")\n</pre>  # Get details of a specific host host = nr.inventory.hosts[\"arista_switch1\"]  # Print hosname and data print(f\"Hostname: {host.hostname}\") print(f\"Usernamme: {host.username}\") print(f\"Password: {host.password}\") <pre>Hostname: 192.168.1.211\nUsernamme: netadmi1n\nPassword: pass123\n</pre> In\u00a0[6]: Copied! <pre># Prepare Connection Details Dictionary\nconnection_details = {\n    \"host\" : host.hostname,\n    \"username\" : host.data[\"username\"],\n    \"password\" : host.data[\"password\"],\n    \"port\" : host.port\n}\n\n# Print connection details\nprint(connection_details)\n</pre> # Prepare Connection Details Dictionary connection_details = {     \"host\" : host.hostname,     \"username\" : host.data[\"username\"],     \"password\" : host.data[\"password\"],     \"port\" : host.port }  # Print connection details print(connection_details) <pre>{'host': '192.168.1.211', 'username': 'netadmin', 'password': 'pass123', 'port': 443}\n</pre> In\u00a0[7]: Copied! <pre># Establish pyeapi Connection\nimport pyeapi\n\n# Establish connection to the device\n\nconnection = pyeapi.connect(\n    transport=\"https\",\n    host = connection_details[\"host\"],\n    username = connection_details[\"username\"],\n    password = connection_details[\"password\"],\n    port = connection_details[\"port\"]\n)\n\n# Verify connection\nprint(connection)\n</pre> # Establish pyeapi Connection import pyeapi  # Establish connection to the device  connection = pyeapi.connect(     transport=\"https\",     host = connection_details[\"host\"],     username = connection_details[\"username\"],     password = connection_details[\"password\"],     port = connection_details[\"port\"] )  # Verify connection print(connection) <pre>EapiConnection(transport=https://192.168.1.211:443//command-api)\n</pre> In\u00a0[8]: Copied! <pre> # Test pyeapi Commands\nfrom pprint import pprint\n # Create an eAPI client\nnode = pyeapi.client.Node(connection)\n\n# Run the \"show version\" command\nresponse = node.enable(\"show version\")\n\n# Print the raw response\npprint(response)\n</pre>  # Test pyeapi Commands from pprint import pprint  # Create an eAPI client node = pyeapi.client.Node(connection)  # Run the \"show version\" command response = node.enable(\"show version\")  # Print the raw response pprint(response)  <pre>[{'command': 'show version',\n  'encoding': 'json',\n  'result': {'architecture': 'i686',\n             'bootupTimestamp': 1736562121.7597656,\n             'configMacAddress': '00:00:00:00:00:00',\n             'hardwareRevision': '',\n             'hwMacAddress': '00:00:00:00:00:00',\n             'imageFormatVersion': '1.0',\n             'imageOptimization': 'None',\n             'internalBuildId': '91e041b1-47db-4422-b025-5ed27d4ce4a4',\n             'internalVersion': '4.31.0F-33804048.4310F',\n             'isIntlVersion': False,\n             'memFree': 2930284,\n             'memTotal': 3970668,\n             'mfgName': 'Arista',\n             'modelName': 'vEOS-lab',\n             'serialNumber': '70CAABD5730D408A60D24ADAFFEBEDC0',\n             'systemMacAddress': '50:27:f6:27:7a:d9',\n             'uptime': 10673.43,\n             'version': '4.31.0F'}}]\n</pre> In\u00a0[19]: Copied! <pre># Extract model and version\nresult = response[0][\"result\"]\nmodel = result.get(\"modelName\", \"Unknown Model\")\nversion = result.get(\"version\", \"Unknown Version\")\n\npprint(result)\nprint(\"#\" * 100)\nprint(\"\\n\")\n# Print details\nprint(f\"Model: {model}\")\nprint(f\"Version: {version}\")\n</pre> # Extract model and version result = response[0][\"result\"] model = result.get(\"modelName\", \"Unknown Model\") version = result.get(\"version\", \"Unknown Version\")  pprint(result) print(\"#\" * 100) print(\"\\n\") # Print details print(f\"Model: {model}\") print(f\"Version: {version}\") <pre>{'architecture': 'i686',\n 'bootupTimestamp': 1736562121.7597656,\n 'configMacAddress': '00:00:00:00:00:00',\n 'hardwareRevision': '',\n 'hwMacAddress': '00:00:00:00:00:00',\n 'imageFormatVersion': '1.0',\n 'imageOptimization': 'None',\n 'internalBuildId': '91e041b1-47db-4422-b025-5ed27d4ce4a4',\n 'internalVersion': '4.31.0F-33804048.4310F',\n 'isIntlVersion': False,\n 'memFree': 2930284,\n 'memTotal': 3970668,\n 'mfgName': 'Arista',\n 'modelName': 'vEOS-lab',\n 'serialNumber': '70CAABD5730D408A60D24ADAFFEBEDC0',\n 'systemMacAddress': '50:27:f6:27:7a:d9',\n 'uptime': 10673.43,\n 'version': '4.31.0F'}\n####################################################################################################\n\n\nModel: vEOS-lab\nVersion: 4.31.0F\n</pre>"},{"location":"network-automation/03-python/nornir_pyeapi/#step-1-set-up-the-environment","title":"Step 1: Set Up the Environment\u00b6","text":"<ul> <li>Make sure you have the required libraries installed. Run this command in a Jupyter Notebook cell:</li> </ul>"},{"location":"network-automation/03-python/nornir_pyeapi/#step-2-initialize-nornir","title":"Step 2: Initialize Nornir\u00b6","text":"<ul> <li>In your notebook, create a new cell and initialize Nornir:</li> </ul>"},{"location":"network-automation/03-python/nornir_pyeapi/#step-3-access-hosts-in-inventory","title":"Step 3: Access Hosts in Inventory\u00b6","text":"<ul> <li>Let\u2019s inspect the hosts in your inventory:</li> </ul>"},{"location":"network-automation/03-python/nornir_pyeapi/#step-4-access-a-single-hosts-details","title":"Step 4: Access a Single Host\u2019s Details\u00b6","text":"<ul> <li>Access details of one host (e.g., arista_switch1):</li> </ul>"},{"location":"network-automation/03-python/nornir_pyeapi/#step-5-prepare-connection-details-dictionary","title":"Step 5: Prepare Connection Details Dictionary\u00b6","text":"<ul> <li>Now, create a connection details dictionary from the host's data:</li> </ul>"},{"location":"network-automation/03-python/nornir_pyeapi/#step-6-establish-pyeapi-connection","title":"Step 6: Establish pyeapi Connection\u00b6","text":"<ul> <li>Connect to the device using pyeapi:</li> </ul>"},{"location":"network-automation/03-python/nornir_pyeapi/#step-7-test-pyeapi-commands","title":"Step 7: Test pyeapi Commands\u00b6","text":"<ul> <li>Run a simple command (e.g., show version) to verify the connection:</li> </ul>"},{"location":"network-automation/03-python/nornir_pyeapi/#step-8-extract-specific-details-from-the-response","title":"Step 8: Extract Specific Details from the Response\u00b6","text":"<ul> <li>Extract specific details from the response, such as the model and version:</li> </ul>"},{"location":"network-automation/03-python/nornir_pyeapi/#summary-of-steps","title":"Summary of Steps\u00b6","text":"<ul> <li>Access Host Details: Use nr.inventory.hosts.</li> <li>Prepare Connection Dictionary: Extract hostname, username, and password.</li> <li>Establish Connection: Use pyeapi.connect.</li> <li>Test Commands: Run node.enable() to execute commands.</li> <li>Extract Data: Parse the response for desired details.</li> </ul>"},{"location":"network-automation/04-data-models-encodings/","title":"Data Models and Encodings","text":"<p>Understanding how data can be structured and encoded is very important in programming in general and network automation in particular.</p>"},{"location":"network-automation/04-data-models-encodings/#yang-openconfig","title":"YANG &amp; Openconfig","text":"<p>YANG (Yet Another Next Generation) is a data modeling language originally developed for NETCONF and defined in RFC 6020 and then updated in RFC 7950. YANG and NETCONF can be considered as successors to SMIng and SNMP respectively. </p> <p>YANG provides a format-independent way to describe a data model that can be represented in XML or JSON.</p> <p>Jason Edelman, Scott S. Lowe, Matt Oswalt. Network Programmability and Automation, p. 183</p> <p>There are hundreds of YANG data models available both vendor-neutral and vendor-specific. The YANG catalog web site can be helpful if you need to find data models relevant to your tasks.</p> <p>Because of this abundance of data models and lack of coordination between standards developing organizations and vendors it seems that YANG and NETCONF are going the same path SNMP went (i.e. used only for data retrieval, but not configuration). OpenConfig workgroup tries to solve this by providing vendor-neutral data models, but I think that Ivan Pepelnjak's point from 2018 stating that \"seamless multi-vendor network device configuration is still a pipe dream\" still holds in 2020.</p>"},{"location":"network-automation/04-data-models-encodings/#xml","title":"XML","text":"<p>XML (eXtensible Markup Language) although a bit old is still widely used in various APIs. It uses tags to encode data hence is a bit hard to read by humans. It was initially designed for documents but is suitable to represent arbitrary data structures.</p> <p>You can refer to this tutorial to learn more about XML.</p> <p>Let's see how this sample CLI output of Cisco IOS <code>show vlan</code> command can be encoded with XML:</p> CLI outputXML <pre><code>VLAN Name                             Status    Ports\n---- -------------------------------- ---------   -------------------------------\n1    default                          active    Gi3/4, Gi3/5, Gi4/11\n\n&lt;...&gt;\n\nVLAN Type  SAID       MTU   Parent RingNo BridgeNo Stp  BrdgMode Trans1 Trans2\n---- ----- ---------- ----- ------ ------ -------- ---- -------- ------ ------\n1    enet  100001     1500  -      -      -        -    -        0      0\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;root&gt;\n  &lt;vlans&gt;\n    &lt;1&gt;\n      &lt;interfaces&gt;GigabitEthernet3/4&lt;/interfaces&gt;\n      &lt;interfaces&gt;GigabitEthernet3/5&lt;/interfaces&gt;\n      &lt;interfaces&gt;GigabitEthernet4/11&lt;/interfaces&gt;\n      &lt;mtu&gt;1500&lt;/mtu&gt;\n      &lt;name&gt;default&lt;/name&gt;\n      &lt;said&gt;100001&lt;/said&gt;\n      &lt;shutdown&gt;false&lt;/shutdown&gt;\n      &lt;state&gt;active&lt;/state&gt;\n      &lt;trans1&gt;0&lt;/trans1&gt;\n      &lt;trans2&gt;0&lt;/trans2&gt;\n      &lt;type&gt;enet&lt;/type&gt;\n      &lt;vlan_id&gt;1&lt;/vlan_id&gt;\n    &lt;/1&gt;\n  &lt;/vlans&gt;\n&lt;/root&gt;\n</code></pre>"},{"location":"network-automation/04-data-models-encodings/#yaml","title":"YAML","text":"<p>YAML (YAML Ain\u2019t Markup Language) is a human-friendly data serialization format. Because YAML is really easy to read and write it is widely used in modern automation tools  for configuration files and even for defining automation tasks logic (see Ansible).</p> <p>You can refer to this tutorial to learn more about YAML.</p> <p>Here is a <code>show vlan</code> output from previous subsection encoded in YAML:</p> <pre><code>---\nvlans:\n  '1':\n    interfaces:\n    - GigabitEthernet3/4\n    - GigabitEthernet3/5\n    - GigabitEthernet4/11\n    mtu: 1500\n    name: default\n    said: 100001\n    shutdown: false\n    state: active\n    trans1: 0\n    trans2: 0\n    type: enet\n    vlan_id: '1'\n</code></pre> <p>Bonus: a collection of YAML shortcomings.</p>"},{"location":"network-automation/04-data-models-encodings/#json","title":"JSON","text":"<p>JSON (JavaScript Object Notation) is a modern data encoding format defined in RFC 7159 and widely used in web APIs. It's lightweight, human-readable, and is more suited for data models of modern programming languages than XML.</p> <p>You can refer to this tutorial to learn more about JSON.</p> <p>Here is the sample data from previous sections encoded in JSON:</p> <p><pre><code>{\n  \"vlans\": {\n    \"1\": {\n      \"interfaces\": [\n        \"GigabitEthernet3/4\",\n        \"GigabitEthernet3/5\",\n        \"GigabitEthernet4/11\"\n      ],\n      \"mtu\": 1500,\n      \"name\": \"default\",\n      \"said\": 100001,\n      \"shutdown\": false,\n      \"state\": \"active\",\n      \"trans1\": 0,\n      \"trans2\": 0,\n      \"type\": \"enet\",\n      \"vlan_id\": \"1\"\n    }\n  }\n}\n</code></pre> As you can see it's almost as easy to read as YAML, however, native JSON doesn't support comments making it not very suitable for configuration files.</p>"},{"location":"network-automation/04-data-models-encodings/#summary","title":"Summary","text":"<p>Here is a summary table representing the key properties of the described data formats.</p> XML YAML JSON Human readable not really yes yes Purpose documents, APIs configuration files APIs Python libs xml, lxml PyYAML json <p>There are online tools like this one to convert data between all three formats.</p>"},{"location":"network-automation/05-technologies/","title":"Technologies","text":"<p>This section is quite opinionated and aims to introduce you to the essential tools leaving behind many others for the sake of brevity. I highly recommend to take a look at the Awesome Network Automation list later.</p>"},{"location":"network-automation/05-technologies/01-python/","title":"Python","text":"<p>Python is a go-to programming language when it comes to network automation. All of the popular network automation tools and libraries are written in Python.</p> <p> </p> Python <p>Due to its gentle learning curve and immense popularity (second most used language on GitHub after JavaScript as of the time of writing), Python is a great choice to get started with programming.</p> <p>Python basics are out of the scope of this guide. I've supplied several online resources that can help with learning Python in the References and further reading section.</p> <p>To effectively use Python to solve basic network automation problems you will need to learn this set of skills:</p> <ul> <li>Setting up Python on your system</li> <li>Using virtual environments and installing packages with Pip</li> <li>Understanding of the basic Python concepts such as:</li> <li>Variables</li> <li>Data structures</li> <li>Functions</li> <li>Imports</li> </ul> <p>As you can see it's not overwhelming and I encourage you to spend some time on it because it'll make your automation journey so much easier.</p>"},{"location":"network-automation/05-technologies/02-interacting/","title":"Interacting with network devices","text":"<p>There are two major ways of accessing network devices programmatically: CLI and API.</p>"},{"location":"network-automation/05-technologies/02-interacting/#cli","title":"CLI","text":"<p>For a long time, the only API of network devices was CLI which is designed to be used by humans and not automation scripts. These are the main drawbacks of using CLI as an API: * Inconsistent output   The same command outputs may differ from one NOS (Network Operating System) version to another. * Unstructured data   Data returned by command execution in CLI is plain text, which means you have to manually parse it (i.e. CLI scraping) * Unreliable command execution   You don't get a status code of an executed command and have to parse the output to determine whether the command succeeded or failed.</p> <p>Despite more and more networking vendors begin to include API support in their products it's unlikely that you won't have to deal with CLI during your network automation journey.</p> <p>To parse CLI output regular expressions are used. Not a very user-friendly technology to put it mildly.</p> <p>\u201cI don\u2019t know who you are. I don\u2019t know what you want. If you are looking for technical help, I can tell you I don\u2019t have any time. But what I do have are a very particular set of regexes. Regexes I have acquired over a very long career. Regexes that are a nightmare for people like you to debug. If you leave me alone now, that\u2019ll be the end of it. I will not look for you, I will not pursue you, but if you don\u2019t, I will look for you, I will find you and I will use them in your code.\u201d</p> <p>Quotes from the Cloudiest WebScaliest DevOps Teams</p> <p>Fortunately, there are a lot of tools and libraries today that make CLI scraping easier by doing a lot of the regex heavy lifting.</p>"},{"location":"network-automation/05-technologies/02-interacting/#apis","title":"APIs","text":"<p>If you are lucky and devices in your network have an API or maybe are even driven by SDN controller this section is for you. Network APIs fall into two major categories: HTTP-based and NETCONF-based.</p>"},{"location":"network-automation/05-technologies/02-interacting/#restful-apis","title":"RESTful APIs","text":"<p>REST stands for Representational State Transfer and defines a set of properties and constraints which an API must conform to in order to be called RESTful.</p> <p> </p> Insulting made easy <p>HTTP-based APIs may be RESTful and non-RESTful. Non-RESTful HTTP-based APIs are left out of scope because they are less common.</p> <p>RESTful APIs are quite easy to use and understand because they are based on HTTP protocol. Basically, RESTful API is just a set of HTTP URLs on which you can make GET and/or POST requests except for returned data is encoded in JSON or XML, not HTML. Since RESTful APIs are HTTP-based they are stateless by nature. This means each request is independent of another and has to supply all the needed information to be properly processed.</p> <p>To explore RESTful APIs you can use tools such as cURL or Postman, but when you are ready to write some code utilizing RESTful API you can use a Python library called requests.</p> <p>There are several mock REST APIs online which you can use for practice. For example, kanye.rest and JSONPlaceholder.</p>"},{"location":"network-automation/05-technologies/02-interacting/#netconf-restconf","title":"NETCONF &amp; RESTCONF","text":"<p>NETCONF is a protocol specifically designed for managing network devices. Unlike REST it uses SSH as transport and is stateful as a result. The other key differences of NETCONF are clear delineation between configurational and operational data and the concept of configuration datastores. NETCONF defines three datastores: running configuration, startup configuration, and candidate configuration. You may be familiar with all three of them in the context of network devices. The candidate configuration concept allows to deliver a configuration change consisting of many commands as one transaction. This means that if only one command in a transaction fails the transaction does not succeed avoiding a situation when the partial configuration is applied.</p> <p>Exploring NETCONF APIs is not as easy and straightforward as with RESTful APIs. To do so you need to establish an interactive SSH session to a device and send lengthy XML-encoded commands. To access NETCONF APIs programmatically there is a ncclient Python library.</p> <p>RESTCONF is another standard protocol which implements a subset of NETCONF functionality (e.g. transactions are not supported) and uses HTTP as transport and is RESTful.</p> <p>When choosing between NETCONF and RESTCONF it's advised to use the former for direct interactions with network devices and the latter for interactions with SDN-controllers and/or orchestrators.</p>"},{"location":"network-automation/05-technologies/02-interacting/#grpc-gnmi","title":"gRPC &amp; gNMI","text":"<p>gNMI is a new addition to network management protocols based on Google's gRPC and developed by OpenConfig working group. It is considered to be a more robust successor of NETCONF and supports streaming telemetry.</p> <p>Because gNMI is not yet as mature as NETCONF it is not very well supported in Python. Though there are a couple of libraries you can look into: cisco-gnmi and pygnmi.</p>"},{"location":"network-automation/05-technologies/02-interacting/#summary","title":"Summary","text":"<p>Here is a summary table representing the key properties of network API types.</p> REST NETCONF RESTCONF gNMI RFC - RFC 6241 RFC 8040 Draft Transport HTTP SSH HTTP gRPC (HTTP/2.0) Data encoding XML, JSON XML XML, JSON ProtoBuf (binary) Transaction support \u274c \u2705 \u274c \u2705 Python libs requests ncclient requests cisco-gnmi, pygnmi"},{"location":"network-automation/05-technologies/03-git/","title":"Git","text":"<p>This section covers basic Git usage and terminology. But first, I'd like to highlight several reasons why you should care about Git and version control in the first place.</p> <p> </p> Git"},{"location":"network-automation/05-technologies/03-git/#why-use-git","title":"Why use Git?","text":"<ul> <li>Visibility &amp; control   By placing your scripts, configuration templates, or even device configurations in Git you can start tracking all the changes and rollback to previous versions if needed.</li> <li>Experimenting   When working on a new feature it's very convenient to create a new branch in the same Git repository rather than copy the whole working directory to a new place.</li> <li>Teamwork   Sooner or later you'll need to share your work with your teammates. Git is the best tool to collaborate without the need to send each other file copies.</li> <li>CI/CD   CI/CD processes are based around source control. Events such as commits or branch merging trigger CI/CD pipelines.</li> </ul>"},{"location":"network-automation/05-technologies/03-git/#terminology","title":"Terminology","text":""},{"location":"network-automation/05-technologies/03-git/#repository","title":"Repository","text":"<p>Git repository is a project's directory containing all the project files plus a hidden directory named <code>.git</code> where all the Git metadata (change history, configuration, etc.) resides. In the example below <code>example-repo</code> is a Git repository.</p> <pre><code>example-repo\n\u251c\u2500\u2500 .git\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ...\n\u251c\u2500\u2500 file1\n\u2514\u2500\u2500 file2\n...\n</code></pre> <p>Git repository consists of three \"trees\". The first one is your <code>Working Directory</code> or <code>Working Tree</code> where all the files you work with stay. The second one is the <code>Index</code> where you put files to be committed by issuing a <code>git add</code> command and finally the <code>HEAD</code> which points to the last commit you've made. <code>Index</code> and <code>HEAD</code> are stored in a <code>.git</code> subdirectory and you never interact with them directly.</p> <p>Git repository can be local or remote. All the changes you make to the working directory are stored in a local repository. The synchronization between local and remote repositories is always done manually.</p>"},{"location":"network-automation/05-technologies/03-git/#working-directory","title":"Working directory","text":"<p>Think of a Git working directory as a sandbox where you make changes to your project's files. Here is a good explanation from the official documentation:</p> <p>Finally, you have your working directory (also commonly referred to as the \u201cworking tree\u201d). The other two trees store their content in an efficient but inconvenient manner, inside the .git folder. The working directory unpacks them into actual files, which makes it much easier for you to edit them. Think of the working directory as a sandbox, where you can try changes out before committing them to your staging area (index) and then to history.</p>"},{"location":"network-automation/05-technologies/03-git/#staging","title":"Staging","text":"<p>When you want to put your changes to Git history, i.e. make a commit, you choose which files you want to commit and issue a <code>git add</code> on them. This way you can put changes in different files to different commits thus grouping them by their function or meaning. Staging also enables you to review your changes before committing.</p>"},{"location":"network-automation/05-technologies/03-git/#commit","title":"Commit","text":"<p>Commit saves staged changes to the local Git repository. It also includes metadata such as the author, the date of the commit, and a commit message.</p>"},{"location":"network-automation/05-technologies/03-git/#branch","title":"Branch","text":"<p>When you feel like adding a new feature or want to refactor the existing code it's a good idea to create a new branch, do your work there, and then merge it back to the main branch. This gives you confidence that you wouldn't break the existing code. It also allows different developers to work on the same codebase without blocking each other.</p> <p>Git branching is extremely lightweight and allows to create new branches and switch between them almost instantaneously.</p>"},{"location":"network-automation/05-technologies/03-git/#pull-merge-request","title":"Pull (merge) request","text":"<p>Pull (GitHub) or merge (GitLab) request is a feature specific to web-based Git-repository managers that provides a simple way to submit your work to the project. There is a lot of confusion about why it's called a pull request and not a push request as you want to add your changes to the repo. The reasoning behind this naming is simple. When you create a pull request you actually request the project's maintainer to pull your submitted changes to the repository.</p>"},{"location":"network-automation/05-technologies/03-git/#basic-usage","title":"Basic usage","text":""},{"location":"network-automation/05-technologies/03-git/#command-line","title":"Command line","text":"<p>To start using Git in the command line I recommend taking a look at this simple but useful guide for the beginners by Roger Dudler.</p>"},{"location":"network-automation/05-technologies/03-git/#dealing-with-mistakes","title":"Dealing with mistakes","text":"<p>Eventually, you will screw something up (e.g. make a commit to the wrong branch). For such situations, there is a good resource that can help with common Git headaches.</p>"},{"location":"network-automation/05-technologies/03-git/#gitignore","title":".gitignore","text":"<p>To make Git ignore specific files or even subdirectories you can list them in a special file called <code>.gitignore</code>. This is extremely useful when you want to keep your remote repository clean of temporary files or files containing sensitive information (e.g. passwords).</p>"},{"location":"network-automation/05-technologies/04-docker/","title":"Docker and containers","text":"<p>Linux containers have been around for quite a long time (and chroot and jail even longer) but Docker was what made it popular and accessible.</p> <p> </p> Containers <p>Containers allow to run software in an isolated environment, but contrary to VMs each container doesn't need a full-blown OS to run. This makes containers more resource-effective in terms of CPU, RAM, and storage not to mention that you don't need to maintain a separate OS for each container as with VMs.</p> <p>Docker (Docker Engine, to be precise) is a software that creates, deletes, and runs containers. You can think of it as similar to ESXi. Docker's ease of use is what made containers so popular.</p>"},{"location":"network-automation/05-technologies/04-docker/#why-use-docker","title":"Why use Docker?","text":"<p>What are the main reasons to use containers in general:</p> <ul> <li>Isolation   An application running inside a container has all the libraries of specific versions it needs. If another application needs other versions of the same libraries just use another container image.</li> <li>Portability   This comes as a result of the previous point. If you've managed to run your application inside a container you can easily run it anywhere where Docker is installed because the application environment doesn't change.</li> <li>Scalability   You can easily create lots of containers to distribute load between them (see Kubernetes)</li> <li>Performance   Faster to create, quicker to start, consume fewer resources.</li> <li>Community   There are millions of ready-made docker images on dockerhub which you can use directly or build your own images upon them.</li> </ul>"},{"location":"network-automation/05-technologies/04-docker/#basic-terminology","title":"Basic Terminology","text":"<p>To familiarize yourself with Docker you need to know the basic terminology and tools.</p> <p>Containerization topic is really huge and I don't want to go deep into technicalities here. If you want to learn more about Docker and containers I can recommend a book called Docker Deep Dive by Nigel Poulton\"</p>"},{"location":"network-automation/05-technologies/04-docker/#images","title":"Images","text":"<p>To continue the VM analogy you can think of Docker images as VM templates. An image contains all the necessary files to run a container and can hold predefined parameters, such as which TCP ports to expose. When you start a container you can override these parameters and add your own. You can run multiple containers from a single image. It is crucial to understand that containers themselves are ephemeral or stateless. This means that when you make any changes to the container's filesystem when it's running it won't persist after you restart that container. If you need persistency you should use external storage solutions such as volumes.</p>"},{"location":"network-automation/05-technologies/04-docker/#layers","title":"Layers","text":"<p>Docker images are made of layers. Essentially, a layer is a bunch of files created after running a command in a Dockerfile. If to build another image you use the same commands in a Dockerfile Docker will just reuse the previously created layer. This speeds up image building and saves storage space.</p>"},{"location":"network-automation/05-technologies/04-docker/#tags","title":"Tags","text":"<p>When you are using different versions of the same image you need a way to distinguish between them. That's where tags come in handy. When creating an image or pulling one from a repository you should specify a tag (e.g. python:3.8.5-slim-buster where 3.8.5-slim-buster is a tag), if you don't the <code>latest</code> tag will be used. Please note that <code>latest</code> has no special meaning, it's just a tag which not necessarily denotes the latest version of the image.</p>"},{"location":"network-automation/05-technologies/04-docker/#volumes","title":"Volumes","text":"<p>When starting a container you can specify directories or files to be mounted inside the container filesystem. Each such directory or file is called a volume. Volumes come in handy when you need the data to persist or to be shared among different containers. It's also an easy way to insert a custom config file into a container, or to use a container as a runtime environment for your script which is mounted inside a container so you can test it without the need to rebuild the container image.</p>"},{"location":"network-automation/05-technologies/04-docker/#dockerfiles","title":"Dockerfiles","text":"<p>Dockerfile is a text file with a set of instructions on how to build an image. It consists of the commands specifying such things as what another image should be used as a base image, what files to copy into the image, what packets to install, and so on.</p>"},{"location":"network-automation/05-technologies/04-docker/#docker-compose","title":"Docker Compose","text":"<p>Docker-compose is a simple orchestrator for Docker containers. To start several containers without docker-compose you need to type a lot of long commands with a multitude of arguments. Docker-compose allows you to specify all those arguments in a simple and clean manner of the YAML file. It also allows you to specify dependencies between containers, i.e. in what order they should start. But even if you need to run only one container it's better to write a <code>docker-compose.yml</code> just to place all those arguments on record.</p>"},{"location":"network-automation/05-technologies/04-docker/#docker-use-cases-for-network-automation","title":"Docker use cases for network automation","text":"<p>When talking about network automation Docker can come in handy in two major ways:</p> <ul> <li>You can build your own automation tools to run in Docker making them portable and automating the packaging process as a result.</li> <li>Most modern tools have dockerized versions that you can run by entering just one command. This one is really useful when you want to follow a tutorial or to try out a new tool but doesn't want to waste time on setup (which can be quite nontrivial)</li> </ul> <p>Here is a simple workflow to build and run your own Docker container:</p> <ul> <li>Write a <code>Dockerfile</code></li> <li>Write a <code>docker-compose.yml</code> file</li> <li>Run <code>docker-compose up</code></li> </ul> <p>There are tons of articles on how to write Dockerfiles and use docker-compose. But I guess at first you will use prebuilt images just to get familiar with Docker and you will need to know some basic CLI commands to start, stop. and monitor Docker containers. Here is a good write up on the essential Docker commands you will find useful from the start.</p>"},{"location":"network-automation/06-automation-tools/","title":"Automation Tools","text":"<p>Here I would like to give you a quick overview of the most popular and prominent network automation tools.</p>"},{"location":"network-automation/06-automation-tools/01-connection/","title":"Connection Management and CLI Scraping","text":""},{"location":"network-automation/06-automation-tools/01-connection/#netmiko","title":"Netmiko","text":"<p>Netmiko is a Python library based on paramiko and aimed to simplify SSH access to network devices. Created by Kirk Byers in 2014 this Python library stays the most popular and widely used tool for managing SSH connections to network devices.</p>"},{"location":"network-automation/06-automation-tools/01-connection/#scrapli","title":"Scrapli","text":"<p>Scrapli is a somewhat new python library (first release in 2019) that solves the same problems as Netmiko but aims to be \"as fast and flexible as possible\".</p>"},{"location":"network-automation/06-automation-tools/02-parsing/","title":"Parsing","text":""},{"location":"network-automation/06-automation-tools/02-parsing/#textfsm-and-ntc-templates","title":"TextFSM and NTC Templates","text":"<p>TextFSM is a Python module created by Google which purpose is to parse semi-formatted text (i.e. CLI output). It takes a template file and text as input and produces structured output. NTC templates is a collection of TextFSM templates for a variety of networking vendors. TextFSM can be used in conjunction with netmiko and scrapli.</p>"},{"location":"network-automation/06-automation-tools/02-parsing/#ttp-template-text-parser","title":"TTP (Template Text Parser)","text":"<p>TTP is the newest addition to the text parsing tools. It's also based on templates that resemble Jinja2 syntax but work in reverse. A simple TTP template looks much like the text it is aimed to parse but the parts you want to extract are put in {{ curly braces }}. It doesn't have a collection of prebuilt templates but given its relative ease of use, you can quickly create your own.</p>"},{"location":"network-automation/06-automation-tools/02-parsing/#pyats-genie","title":"PyATS &amp; Genie","text":"<p>These internal Cisco tools were publicly released a few years back and continue to develop rapidly. PyATS is a testing and automation framework. It has a lot to it and I encourage you to learn about it on Cisco DevNet resources. Here I would like to focus on two libraries within the PyATS framework: Genie parser and Dq. The first one as the name implies is aimed to parse CLI output and has a huge collection (2000+) of ready-made parsers for various devices (not limited to Cisco). The second one, Dq, is a great time saver when you need to access the parsed data. Often parsers such as Genie return data in complex data structures (e.g. nested dictionaries) and to access something you would need loops if statements and a strong understanding of where to look. With Dq, you can make queries without much caring of where in a nested structure your data resides.</p>"},{"location":"network-automation/06-automation-tools/03-configuring/","title":"Configuring devices","text":""},{"location":"network-automation/06-automation-tools/03-configuring/#napalm","title":"NAPALM","text":"<p>As the official documentation states</p> <p>NAPALM (Network Automation and Programmability Abstraction Layer with Multivendor support) is a Python library that implements a set of functions to interact with different network device Operating Systems using a unified API.</p>"},{"location":"network-automation/06-automation-tools/03-configuring/#supported-devices","title":"Supported devices","text":"<p>As of the time of writing NAPALM supported the following network operating systems:</p> <ul> <li>Arista EOS</li> <li>Cisco IOS</li> <li>Cisco IOS-XR</li> <li>Cisco NX-OS</li> <li>Juniper JunOS</li> </ul>"},{"location":"network-automation/06-automation-tools/03-configuring/#working-with-device-configuration","title":"Working with device configuration","text":"<p>With NAPALM you can push configuration and retrieve operational data from  devices. When manipulating device configuration you have two options:</p> <ul> <li>Replace the entire running configuration with a new one</li> <li>Merge the existing running configuration with a new one</li> </ul> <p>Replace and merge operations don't apply at once. Before committing the new configuration you can compare it to the currently running configuration and then either commit or discard it. And even after applying the new config, you have an option to rollback to the previously committed configuration if the network OS supports it. </p>"},{"location":"network-automation/06-automation-tools/03-configuring/#validating-deployment","title":"Validating deployment","text":"<p>The ability to retrieve operational data from devices brings a powerful NAPALM feature called compliance report or deployment validation. To get a compliance report you need to write a YAML file describing the desired state of the device and tell NAPALM to use it against the device with a <code>compliance_report</code> method.</p>"},{"location":"network-automation/06-automation-tools/03-configuring/#integration-with-other-tools","title":"Integration with other tools","text":"<p>Being a Python library NAPALM can be used directly in Python scripts or integrated with Ansible (napalm-ansible module), Nornir (nornir_napalm plugin) or SaltStack (native support).</p>"},{"location":"network-automation/06-automation-tools/03-configuring/#ansible","title":"Ansible","text":"<p>Ansible is a comprehensive automation framework initially developed to provision Linux servers. Due to its agentless nature, Ansible soon became very popular among network engineers. Contrary to the agent-based systems like Chef and Puppet, Ansible executes Python code on the target systems to perform its tasks. Therefore it only requires the target system to run SSH and Python. But how does it align with the network devices which cannot execute Python code? To solve this Ansible executes its network modules locally on the control node. </p>"},{"location":"network-automation/06-automation-tools/03-configuring/#ansible-galaxy","title":"Ansible Galaxy","text":"<p>To interact with different network platforms Ansible uses plugins grouped in collections. To install these collections you can use Ansible Galaxy which is like DockerHub or PyPi for Ansible, where users can share Ansible roles and plugins.</p>"},{"location":"network-automation/06-automation-tools/03-configuring/#terminology","title":"Terminology","text":"<p>Typical Ansible automation project consists of the following building blocks.</p>"},{"location":"network-automation/06-automation-tools/03-configuring/#inventory","title":"Inventory","text":"<p>Inventory file lists managed network devices, their hostnames or IP addresses, and optionally other variables like access credentials. Ansible can use Netbox as an inventory information source via a plugin.</p>"},{"location":"network-automation/06-automation-tools/03-configuring/#playbooks","title":"Playbooks","text":"<p>A playbook defines an ordered list of tasks to be performed against managed devices. It also can define which roles should be applied to devices.</p>"},{"location":"network-automation/06-automation-tools/03-configuring/#roles","title":"Roles","text":"<p>As the official documentation states</p> <p>Ansible roles are basically playbooks broken up into a known file structure.</p> <p>Roles allow you to group tasks and variables in separate directories. This makes an Ansible project more organized and lets you reuse those roles on different groups of managed hosts more easily.</p> <p>You can create roles according to different configuration sections: one for routing, another for basic settings such as NTP and DNS servers, etc. etc. Then you can apply those roles to different groups of devices. For example, routing is needed only on the core switches, and basic settings should be applied to all devices.</p>"},{"location":"network-automation/06-automation-tools/03-configuring/#pros-cons","title":"Pros &amp; Cons","text":"<p>Ansible uses its own DSL based on YAML to describe its playbooks logic. This design decision can be considered a two-edged sword. It requires minimal learning to solve simple tasks, but when you need to write something more complex it quickly becomes quite cumbersome and hard to debug.</p> <p>Speed and scalability are other aspects where Ansible doesn't shine in the context of network automation. </p> <p>In my opinion, Ansible is a great starting point for your network automation journey, as it is easy to learn and gives you a good idea of what modern automation tools are about. As John McGovern from CBT Nuggets said \"Ansible is like a CCNA for network automation\".</p> <p>Another Ansible advantage is that it can be used as a single automation solution for the whole IT infrastructure.</p>"},{"location":"network-automation/06-automation-tools/03-configuring/#nornir","title":"Nornir","text":"<p>Nornir was initially created by David Barroso, author of NAPALM.</p> <p>Nornir is an automation framework written in python to be used with python.</p> <p>Official Nornir documentation</p> <p>The last part of the definition is key here. Unlike Ansible, Nornir uses pure Python for describing its tasks (Nornir tasks are essentially Python functions). This makes Nornir far more flexible, fast, and easy to debug.</p> <p>Another aspect of Nornir being purely Python is that when you learn Nornir you also learn Python.</p> <p>Nornir is a pluggable system and starting with version 3.0 it comes only with the very basic plugins. A list of Nornir plugins can be found here. Plugins are installed with Python's standard package manager pip.</p> <p>Like Ansible, Nornir has a concept of inventory, which also can be written in YAML (YAMLInventory plugin), where you put host and group variables. You can also use existing Ansible inventory files (nornir_ansible) or take your inventory information directly from Netbox with nornir_netbox.</p> <p>To interact with network devices, Nornir can leverage NAPALM, netmiko, and scrapli libraries via respective plugins.</p>"},{"location":"network-automation/06-automation-tools/04-summary/","title":"Summary","text":"<p>All of the described tools have their advantages and use cases. I would recommend starting with more high-level tools such as NAPALM, Ansible, or Nornir.</p>"},{"location":"network-automation/07-text-editors/","title":"Text editors","text":"<p>A text editor is a piece of software you will spend most of your time with while automating networks. Here I would like to make an overview of the most popular modern text editors.</p>"},{"location":"network-automation/07-text-editors/#vs-code","title":"VS Code","text":"<p>Good or bad, but today's text editor market is clearly dominated by Visual Studio Code. It has a great and ever-expanding collection of plugins, nice UI, built-in Git support, intelligent code completion, you name it.</p> <p>VS Code is a free and open-source text editor built on Electron and owned by Microsoft. It was initially released in 2015.</p>"},{"location":"network-automation/07-text-editors/#atom","title":"Atom","text":"<p>Atom is another highly customizable open-source text editor created by GitHub. Since GitHub was acquired by Microsoft, Atom now is also a Microsoft product.</p> <p>Atom also is free, open-source, and built on Electron. It was initially released in 2014.</p>"},{"location":"network-automation/07-text-editors/#pycharm","title":"PyCharm","text":"<p>PyCharm is a full-blown Python IDE by JetBrains. I've heard a lot of praise towards it in the context of Python development, but never tried it myself. PyCharm is shipped in two versions: full-featured Professional ($89/year subscription license) and less functional but free Community Edition.</p> <p>PyCharm was initially released in 2010.</p>"},{"location":"network-automation/07-text-editors/#sublime-text","title":"Sublime Text","text":"<p>Sublime is the oldest text editor on the list. It has some great features to itself like multiline editing and \"Go To Anything\" command which allows to quickly jump to the specific part of the text in any open tab. It also can be extended with plugins, but the package manager is not included by default and you'll have to install it manually first.</p> <p>Sublime Text is a proprietary paid software written in C++ and initially released in 2008. It has a 30 day trial period. After that, you will be kindly reminded from time to time to buy an $80 license.</p>"},{"location":"network-automation/07-text-editors/#summary","title":"Summary","text":"<p>Learning to use a new text editor with all its shortcuts and plugins is a long-term time investment. If you haven't used any of these text editors I recommend picking VS Code as the most future-proof and well-rounded solution.</p>"}]}